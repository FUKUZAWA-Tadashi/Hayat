/*  -*- coding: sjis-dos; -*-  */

/*
 * copyright 2010 FUKUZAWA Tadashi.  All rights reserved.
 */

#include "hyCFileOut.h"
#include "hyMMes.h"
#include <sys/stat.h>

void Hayat::Compiler::writeGenHead(FILE* fp)
{
    fprintf(fp, "/* this file was automatically generated by Hayat compiler */\n");
    fprintf(fp, "/* !!! DO NOT EDIT !!! */\n");
}


using namespace Hayat::Compiler;


DiffWrite::DwMode_e DiffWrite::m_defaultMode = DiffWrite::DW_DIFFWRITE;

DiffWrite::DiffWrite(void)
    : m_fp(NULL)
{
}

DiffWrite::DiffWrite(const char* path, DwMode_e mode)
    : m_fp(NULL)
{
    open(path, mode);
}

DiffWrite::~DiffWrite()
{
    if (m_fp != NULL) {
        close();
    }
}

void DiffWrite::setDefaultMode(DwMode_e mode)
{
    HMD_ASSERT(mode == DW_OVERWRITE || mode == DW_DIFFWRITE);
    m_defaultMode = mode;
}

FILE* DiffWrite::open(const char* path, DwMode_e mode)
{
    HMD_ASSERT(m_fp == NULL);
    if (mode == DW_DEFAULT) mode = m_defaultMode;
    m_mode = mode;
    m_orgPath = path;
    if (mode == DW_DIFFWRITE) {
        size_t len = HMD_STRLEN(path);
        HMD_ASSERT(len > 0);
        len += 20;
        m_tmpPath = new char[len];
        HMD_STRNCPY(m_tmpPath, path, len);
        HMD_STRSCAT(m_tmpPath, "_diffwrite_tmp_", len);
        m_fp = hmd_fopen(m_tmpPath, "wb");
    } else {
        m_fp = hmd_fopen(m_orgPath, "wb");
    }
    return m_fp;
}

void DiffWrite::close(void)
{
    HMD_ASSERT(m_fp != NULL);
    fclose(m_fp);
    m_fp = NULL;

    if (m_mode != DW_DIFFWRITE)
        return;

    struct stat stbuf;
    if (stat(m_orgPath, &stbuf) != 0) {
        // m_orgPathは無かったのでmvして終わり
        hmd_mv_file(m_tmpPath, m_orgPath);
        delete[] m_tmpPath;
        return;
    }
    off_t orgSize = stbuf.st_size;
    if (stat(m_tmpPath, &stbuf) != 0) {
        // 今closeしたのになぜかstatできない？
        HMD_FATAL_ERROR("cannot stat %s", m_tmpPath);
        delete[] m_tmpPath;
        return;
    }
    off_t tmpSize = stbuf.st_size;
    if (orgSize == tmpSize) {
        // サイズは同じなので中身比較
        FILE* ofp = hmd_fopen(m_orgPath, "rb");
        HMD_ASSERTMSG(ofp != NULL, M_M("cannot read %s"), m_orgPath);
        FILE* tfp = hmd_fopen(m_tmpPath, "rb");
        HMD_ASSERTMSG(tfp != NULL, M_M("cannot read %s"), m_tmpPath);
        
        char buf1[256], buf2[256];
        for (;;) {
            if (feof(ofp) && feof(tfp)) {
                // 中身が一致した
                fclose(tfp); fclose(ofp);
                hmd_rm_file(m_tmpPath);
                delete[] m_tmpPath;
                return;
            }
            size_t on = fread(buf1, sizeof(char), 256, ofp);
            size_t tn = fread(buf2, sizeof(char), 256, tfp);
            if (on != tn)
                break;
            if (memcmp(buf1, buf2, on) != 0)
                break;
        }
        // 中身が異なる
         fclose(tfp); fclose(ofp);
    } // else サイズが違う
    hmd_mv_file(m_tmpPath, m_orgPath);
    delete[] m_tmpPath;
}
