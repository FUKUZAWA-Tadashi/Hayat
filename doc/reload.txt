バイトコードリロード



callBytecodeTopでスレッドにて徐々に実行するものは、リロードではなく
アンロード→ロードにすべき。
リロードした場合は、execBytecodeTopを内部で呼び出している。
※execBytecodeTopを実行しないモードが必要か？



手順

GC::collect() で sweep後の状態にしておく。
CodeManager::reloadBytecode() または overrideBytecode() を呼んで、
バイトコードをリロードする。



* スクリプトから
Bytecode.reload() でリロードできる。
Bytecode.reloadAs() で、ファイル名と違う名前でリロードする事ができる。



実行中のバイトコードが存在する間、一時的に新旧バイトコードが同居する。
文字列定数はバイトコード中に含まれているため、文字列定数を参照するデー
タが存在していると、バイトコードは使用中と見做される。


* CodeManager
旧バイトコードは m_tbl から m_replaced に移管。
新バイトコードが m_tbl で管理される。

GCのsweepフェーズで gCodeManager.deleteUnnecessaryBytecode() が呼ばれ、
旧バイトコードが実行されなくなっていた場合はバイトコードが削除される。



* HClass
クラス変数、定数、メソッド引数デフォルト値 が、m_varPoolにストアされている。
クラス変数と定数は、スーパークラスのものを共用している。
クラス変数の実体の場所を検索するためのハッシュが m_classVarHash
定数の実体の場所を検索するためのハッシュが m_constVarHash

バイトコードリロードを実行すると以下の操作を行なう。

・新クラス初期化
	新クラスの m_varPool が確保され、旧クラスの存在を無視した状態で
	ハッシュを初期化する。
	デフォルト値も初期化される。
・値のコピー
	設定によっては、旧クラスのクラス変数の値を新クラスにコピーする。
		(デフォルトではコピーする)
	設定によっては、旧クラスの定数の値を新クラスにコピーする。
		(デフォルトではコピーする)
	メソッド引数デフォルト値はコピーしない。
・継承の調整
	旧クラスをスーパークラスとしているクラスで、旧クラスの m_varPool
	を指しているハッシュがあれば、新クラスを指すように変更する。
・全オブジェクトの旧クラスへのポインタを新クラスに付け替える
	これは GC::mark にて行なわれる。





*

親クラスのリロードで、子クラスで使用している{メンバ変数,クラス変数}
と同じ名前の変数を追加した場合、子クラスでは、新しく追加された
親クラス側の変数を参照する。
