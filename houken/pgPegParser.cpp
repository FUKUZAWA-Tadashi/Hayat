/* this file is generated by 'houken' parser generator */
#include <stdio.h>
#include <string.h>
#include "pgPegParser.h"


using namespace Hayat::Parser;

Parser_EOF* p__eof;
Parser_AnyChar* p__anychar;
P_Start* p_Start;
P_Directives* p_Directives;
P_Direc_userAction* p_Direc_userAction;
P_ActionParam* p_ActionParam;
P_Direc_ownMes* p_Direc_ownMes;
P_Rules* p_Rules;
P_Rule* p_Rule;
P_DummyRule* p_DummyRule;
P_ErrorMesDef* p_ErrorMesDef;
P_Disjunction* p_Disjunction;
P_Conjunction* p_Conjunction;
P_PrefixExp* p_PrefixExp;
P_SuffixExp* p_SuffixExp;
P_Term* p_Term;
P_Term1* p_Term1;
P_Term2* p_Term2;
P_ErrorCut* p_ErrorCut;
P_OperatorDef* p_OperatorDef;
P_UnaryOp* p_UnaryOp;
P_BinaryOp* p_BinaryOp;
P_TernaryOp* p_TernaryOp;
P_Number* p_Number;
P_AndPred* p_AndPred;
P_NotPred* p_NotPred;
P_NoTree* p_NoTree;
P_Optional* p_Optional;
P_ZeroOrMore* p_ZeroOrMore;
P_OneOrMore* p_OneOrMore;
P_Ident* p_Ident;
P_NotTokenPred* p_NotTokenPred;
P_EndOfFile* p_EndOfFile;
P_AnyChar* p_AnyChar;
P_String* p_String;
P_Token* p_Token;
P_Range* p_Range;
P_XChar* p_XChar;
P_XCharH* p_XCharH;
P_XCharU* p_XCharU;
P_XCharE* p_XCharE;
P_XCharA* p_XCharA;
P_Hex1* p_Hex1;
P_Spc* p_Spc;
P_Comment* p_Comment;

void p__init(void)
{
  p__eof = new Parser_EOF();
  p__anychar = new Parser_AnyChar();
  p_Start = new P_Start();
  p_Directives = new P_Directives();
  p_Direc_userAction = new P_Direc_userAction();
  p_ActionParam = new P_ActionParam();
  p_Direc_ownMes = new P_Direc_ownMes();
  p_Rules = new P_Rules();
  p_Rule = new P_Rule();
  p_DummyRule = new P_DummyRule();
  p_ErrorMesDef = new P_ErrorMesDef();
  p_Disjunction = new P_Disjunction();
  p_Conjunction = new P_Conjunction();
  p_PrefixExp = new P_PrefixExp();
  p_SuffixExp = new P_SuffixExp();
  p_Term = new P_Term();
  p_Term1 = new P_Term1();
  p_Term2 = new P_Term2();
  p_ErrorCut = new P_ErrorCut();
  p_OperatorDef = new P_OperatorDef();
  p_UnaryOp = new P_UnaryOp();
  p_BinaryOp = new P_BinaryOp();
  p_TernaryOp = new P_TernaryOp();
  p_Number = new P_Number();
  p_AndPred = new P_AndPred();
  p_NotPred = new P_NotPred();
  p_NoTree = new P_NoTree();
  p_Optional = new P_Optional();
  p_ZeroOrMore = new P_ZeroOrMore();
  p_OneOrMore = new P_OneOrMore();
  p_Ident = new P_Ident();
  p_NotTokenPred = new P_NotTokenPred();
  p_EndOfFile = new P_EndOfFile();
  p_AnyChar = new P_AnyChar();
  p_String = new P_String();
  p_Token = new P_Token();
  p_Range = new P_Range();
  p_XChar = new P_XChar();
  p_XCharH = new P_XCharH();
  p_XCharU = new P_XCharU();
  p_XCharE = new P_XCharE();
  p_XCharA = new P_XCharA();
  p_Hex1 = new P_Hex1();
  p_Spc = new P_Spc();
  p_Comment = new P_Comment();

  p_Start->construct();
  p_Directives->construct();
  p_Direc_userAction->construct();
  p_ActionParam->construct();
  p_Direc_ownMes->construct();
  p_Rules->construct();
  p_Rule->construct();
  p_DummyRule->construct();
  p_ErrorMesDef->construct();
  p_Disjunction->construct();
  p_Conjunction->construct();
  p_PrefixExp->construct();
  p_SuffixExp->construct();
  p_Term->construct();
  p_Term1->construct();
  p_Term2->construct();
  p_ErrorCut->construct();
  p_OperatorDef->construct();
  p_UnaryOp->construct();
  p_BinaryOp->construct();
  p_TernaryOp->construct();
  p_AndPred->construct();
  p_NotPred->construct();
  p_NoTree->construct();
  p_Optional->construct();
  p_ZeroOrMore->construct();
  p_OneOrMore->construct();
  p_EndOfFile->construct();
  p_AnyChar->construct();
  p_String->construct();
  p_Token->construct();
  p_Range->construct();
  p_XChar->construct();
  p_XCharH->construct();
  p_XCharU->construct();
  p_XCharE->construct();
  p_XCharA->construct();
  p_Hex1->construct();
  p_Spc->construct();
}

void P_Start::construct(void) {
  m_parser = p_Directives->seq(p_Spc->noTree())->seq(p_Rules)->seq(p__eof->noTree());
}

void P_Directives::construct(void) {
  m_parser = p_Spc->noTree()->seq(p_Direc_userAction->choice(p_Direc_ownMes))->star();
}

void P_Direc_userAction::construct(void) {
  m_parser = (new Parser_String(L"$action"))->noTree()->seq((new Parser_ErrorCut(1)))->seq((new Parser_String(L" "))->choice((new Parser_String(L"\t")))->plus()->noTree())->seq(p_Ident)->seq((new Parser_ErrorCut(2)))->seq((new Parser_String(L" "))->choice((new Parser_String(L"\t")))->star()->noTree())->seq((new Parser_String(L"("))->noTree())->seq(p_ActionParam)->seq((new Parser_ErrorCut(3)))->seq((new Parser_String(L")"))->noTree());
}

void P_ActionParam::construct(void) {
  m_parser = (new Parser_String(L")"))->choice((new Parser_String(L"\n")))->choice((new Parser_String(L"\r")))->notPred()->seq(p__anychar->noTree())->star();
}

void P_Direc_ownMes::construct(void) {
  m_parser = (new Parser_String(L"$ownErrorMessage"))->noTree();
}

void P_Rules::construct(void) {
  m_parser = p_Rule->choice(p_OperatorDef)->choice(p_DummyRule)->choice(p_ErrorMesDef)->star();
}

void P_Rule::construct(void) {
  m_parser = p_Ident->seq(p_Spc->noTree())->seq((new Parser_String(L"<-"))->noTree())->seq(p_Spc->noTree())->seq(p_Disjunction);
}

void P_DummyRule::construct(void) {
  m_parser = p_Ident->seq(p_Spc->noTree())->seq((new Parser_String(L"<%"))->noTree())->seq(p_Spc->noTree())->seq(p_Disjunction);
}

void P_ErrorMesDef::construct(void) {
  m_parser = p_Ident->seq((new Parser_String(L"$"))->noTree())->seq(p_Number)->seq(p_Spc->noTree())->seq((new Parser_String(L"="))->noTree())->seq(p_Spc->noTree())->seq(p_String)->seq(p_Spc->noTree());
}

void P_Disjunction::construct(void) {
  m_parser = p_Conjunction->seq((new Parser_String(L"/"))->noTree()->seq(p_Spc->noTree())->seq(p_Conjunction)->star());
}

void P_Conjunction::construct(void) {
  m_parser = p_PrefixExp->choice(p_ErrorCut)->plus();
}

void P_PrefixExp::construct(void) {
  m_parser = p_AndPred->choice(p_NotPred)->choice(p_NoTree)->optional()->seq(p_SuffixExp);
}

void P_SuffixExp::construct(void) {
  m_parser = p_Term->seq(p_Spc->noTree())->seq(p_Optional->choice(p_ZeroOrMore)->choice(p_OneOrMore)->optional());
}

void P_Term::construct(void) {
  m_parser = p_EndOfFile->choice(p_Term1)->choice(p_Term2)->choice(p_String)->choice(p_Token)->choice(p_Range)->choice(p_AnyChar);
}

void P_Term1::construct(void) {
  m_parser = p_Ident->seq((new Parser_String(L"$"))->choice(p_Spc->seq((new Parser_String(L"<"))))->notPred());
}

void P_Term2::construct(void) {
  m_parser = (new Parser_String(L"("))->noTree()->seq(p_Spc->noTree())->seq(p_Disjunction)->seq((new Parser_String(L")"))->noTree());
}

void P_ErrorCut::construct(void) {
  m_parser = (new Parser_String(L"$"))->noTree()->seq((new Parser_ErrorCut(1)))->seq(p_Number)->seq(p_Spc->noTree());
}

void P_OperatorDef::construct(void) {
  m_parser = p_UnaryOp->choice(p_BinaryOp)->choice(p_TernaryOp);
}

void P_UnaryOp::construct(void) {
  m_parser = p_Ident->seq(p_Spc->noTree())->seq((new Parser_String(L"<<"))->noTree())->seq(p_Spc->noTree())->seq((new Parser_String(L"prefix"))->seq(p_NotTokenPred->noTree())->choice((new Parser_String(L"postfix"))->seq(p_NotTokenPred->noTree())))->seq((new Parser_ErrorCut(1)))->seq(p_Spc->noTree())->seq(p_Number)->seq((new Parser_ErrorCut(2)))->seq(p_Spc->noTree())->seq(p_Disjunction);
}

void P_BinaryOp::construct(void) {
  m_parser = p_Ident->seq(p_Spc->noTree())->seq((new Parser_String(L"<<"))->noTree())->seq(p_Spc->noTree())->seq((new Parser_String(L"infixl"))->seq(p_NotTokenPred->noTree())->choice((new Parser_String(L"infixr"))->seq(p_NotTokenPred->noTree()))->choice((new Parser_String(L"infixn"))->seq(p_NotTokenPred->noTree())))->seq((new Parser_ErrorCut(1)))->seq(p_Spc->noTree())->seq(p_Number)->seq((new Parser_ErrorCut(2)))->seq(p_Spc->noTree())->seq(p_Disjunction);
}

void P_TernaryOp::construct(void) {
  m_parser = p_Ident->seq(p_Spc->noTree())->seq((new Parser_String(L"<<"))->noTree())->seq(p_Spc->noTree())->seq((new Parser_String(L"ternary"))->seq(p_NotTokenPred->noTree()))->seq((new Parser_ErrorCut(1)))->seq(p_Spc->noTree())->seq(p_Number)->seq((new Parser_ErrorCut(2)))->seq(p_Spc->noTree())->seq(p_PrefixExp)->seq(p_Spc->noTree())->seq(p_PrefixExp)->seq(p_Spc->noTree());
}

/*
void P_Number::construct(void) {
  m_parser = (new Parser_RangeChar(L'0',L'9'))->plus()->noTree();
}
*/

void P_AndPred::construct(void) {
  m_parser = (new Parser_String(L"&"))->noTree()->seq(p_Spc->noTree());
}

void P_NotPred::construct(void) {
  m_parser = (new Parser_String(L"!"))->noTree()->seq(p_Spc->noTree());
}

void P_NoTree::construct(void) {
  m_parser = (new Parser_String(L"%"))->noTree()->seq(p_Spc->noTree());
}

void P_Optional::construct(void) {
  m_parser = (new Parser_String(L"?"))->noTree()->seq(p_Spc->noTree());
}

void P_ZeroOrMore::construct(void) {
  m_parser = (new Parser_String(L"*"))->noTree()->seq(p_Spc->noTree());
}

void P_OneOrMore::construct(void) {
  m_parser = (new Parser_String(L"+"))->noTree()->seq(p_Spc->noTree());
}

/*
void P_Ident::construct(void) {
  m_parser = p_Ident1->noTree()->seq(p_Ident2->star()->noTree());
}
*/

/*
void P_NotTokenPred::construct(void) {
  m_parser = p_Ident2->notPred();
}
*/

void P_EndOfFile::construct(void) {
  m_parser = (new Parser_String(L"EOF"))->seq(p_NotTokenPred->noTree())->noTree();
}

void P_AnyChar::construct(void) {
  m_parser = (new Parser_String(L"."))->noTree();
}

void P_String::construct(void) {
  m_parser = (new Parser_String(L"\""))->noTree()->seq((new Parser_String(L"\""))->notPred()->seq(p_XChar->noTree())->plus())->seq((new Parser_String(L"\""))->noTree());
}

void P_Token::construct(void) {
  m_parser = (new Parser_String(L"'"))->noTree()->seq(p_Ident)->seq((new Parser_String(L"'"))->noTree());
}

void P_Range::construct(void) {
  m_parser = (new Parser_String(L"["))->noTree()->seq(p_XChar)->seq((new Parser_String(L"-"))->noTree())->seq(p_XChar)->seq((new Parser_String(L"]"))->noTree());
}

void P_XChar::construct(void) {
  m_parser = p_XCharH->choice(p_XCharU)->choice(p_XCharE)->choice(p_XCharA);
}

void P_XCharH::construct(void) {
  m_parser = (new Parser_String(L"\\"))->noTree()->seq((new Parser_String(L"x"))->choice((new Parser_String(L"X")))->noTree())->seq(p_Hex1)->seq(p_Hex1);
}

void P_XCharU::construct(void) {
  m_parser = (new Parser_String(L"\\"))->noTree()->seq((new Parser_String(L"u"))->choice((new Parser_String(L"U")))->noTree())->seq(p_Hex1)->seq(p_Hex1)->seq(p_Hex1)->seq(p_Hex1);
}

void P_XCharE::construct(void) {
  m_parser = (new Parser_String(L"\\"))->noTree()->seq(p__anychar);
}

void P_XCharA::construct(void) {
  m_parser = (new Parser_String(L"\n"))->choice((new Parser_String(L"\r")))->notPred()->seq(p__anychar->noTree());
}

void P_Hex1::construct(void) {
  m_parser = (new Parser_RangeChar(L'0',L'9'))->noTree()->choice((new Parser_RangeChar(L'A',L'F'))->noTree())->choice((new Parser_RangeChar(L'a',L'f'))->noTree());
}

void P_Spc::construct(void) {
  m_parser = (new Parser_String(L" "))->choice((new Parser_String(L"\t")))->choice((new Parser_String(L"\n")))->choice((new Parser_String(L"\r")))->choice(p_Comment)->star()->noTree();
}

/*
void P_Comment::construct(void) {
  m_parser = (new Parser_String(L"#"))->noTree()->seq(p_XCharA->star()->noTree())->seq((new Parser_String(L"\n"))->choice((new Parser_String(L"\r")))->plus()->noTree());
}
*/
void P_Direc_userAction::errorMessage(int errorId, hyu32 pos)
{
  switch (errorId) {
  case 1:
    errorCutMessage(pos, "function name required");
    break;
  case 2:
    errorCutMessage(pos, "function parameter required");
    break;
  case 3:
    errorCutMessage(pos, "missing ')'");
    break;
  default:
    GenParser::errorMessage(errorId, pos);
  }
}
void P_ErrorCut::errorMessage(int errorId, hyu32 pos)
{
  switch (errorId) {
  case 1:
    errorCutMessage(pos, "error cut number required");
    break;
  default:
    GenParser::errorMessage(errorId, pos);
  }
}
void P_UnaryOp::errorMessage(int errorId, hyu32 pos)
{
  switch (errorId) {
  case 1:
    errorCutMessage(pos, "missing precedence");
    break;
  case 2:
    errorCutMessage(pos, "missing rule of parsing unary operator");
    break;
  default:
    GenParser::errorMessage(errorId, pos);
  }
}
void P_BinaryOp::errorMessage(int errorId, hyu32 pos)
{
  switch (errorId) {
  case 1:
    errorCutMessage(pos, "missing precedence");
    break;
  case 2:
    errorCutMessage(pos, "missing rule of parsing binary operator");
    break;
  default:
    GenParser::errorMessage(errorId, pos);
  }
}
void P_TernaryOp::errorMessage(int errorId, hyu32 pos)
{
  switch (errorId) {
  case 1:
    errorCutMessage(pos, "missing precedence");
    break;
  case 2:
    errorCutMessage(pos, "missing rule of parsing binary operator");
    break;
  default:
    GenParser::errorMessage(errorId, pos);
  }
}
